\documentclass{beamer}

\usepackage[orientation=landscape,width=48in,height=36in]{beamerposter}
\usepackage{caption}
\usepackage{float}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{microtype}
\usepackage{ragged2e}

\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\usepackage{xcolor}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}

\hfuzz=2pt % Address overfull hbox warnings from microtype

\lstset{basicstyle=\ttfamily,columns=fullflexible,breaklines=true,frame=shadowbox,keepspaces}

\setbeamertemplate{caption}[numbered]

\title{\Huge A Device Memory Pool Implementation for Omega\_h Applications with Kokkos}
\author{\Large Matthew McCall \inst{1} \and Cameron W. Smith \inst{2}}
\institute{\large \inst{1} mccalm@rpi.edu, Computer Science Undergraduate \inst{2} smithc11@rpi.edu, Scientific Computation Research Center}

\begin{document}

%-----------LOGO ADDED TO NORTH EAST----------------%
\addtobeamertemplate{headline}{} 
{\begin{tikzpicture}[remember picture, overlay]
     \node [anchor=north east, inner sep=4cm]  at (current page.north east)
         {\includegraphics[height=7cm]{rpi_seal.png}};
  \end{tikzpicture}}
%-------END LOGO ADDED TO NORTH EAST----------------%

\begin{frame}
    \maketitle

    \begin{columns}
        \column{0.3\textwidth} 

        \begin{block}{Introduction} 
            A memory pool is a technique for managing memory allocation in a computer program. It consists of a pre-allocated block of memory from which the program can request and release memory from the pool as needed, without invoking the system's memory allocator. This can improve the performance, reliability and portability of the program. Some of the benefits of memory pools are:
            \begin{itemize}
                \item They reduce memory fragmentation, which can cause inefficient use of memory and slow down the program.
                \item They reduce the overhead of system memory allocation and deallocation, which can consume a significant amount of CPU time and introduce latency.
                \item They allow the programmer to control the size and layout of the memory blocks, which can optimize the memory access patterns and cache efficiency.
            \end{itemize}
        \end{block}

        \begin{block}{Background and Related Works}
            \begin{itemize}
                \item Omega\_h \cite{omegah} is a software library written in C++ that provides mesh adaptivity for tetrahedron and triangle meshes, with an emphasis on high-performance computing. It is designed to add adaptive capabilities to existing simulation software. 
                \item Mesh adaptivity allows for the reduction of both discretization error and the number of degrees of freedom during a simulation, as well as enabling simulations with moving objects and changing geometries. 
                \item The design for this pool was inspired by Boost's Simple Segregated Storage \cite{boostsss}, a fixed-size chunk memory-pool implementation targeting host-sided memory. 
                \item An important distinction between Boost's Simple Segregated Storage and other similar host-bound implementations and ours is that the free-list is interweaved into the chunks themselves.
                \item While this reduces memory overhead, storing a free-list in device memory would require copying the free-list to the host, manipulating it, and then copying it back to the device each time an allocation or deallocation is performed. 
            \end{itemize}

            \begin{figure}[H]
                \centering
                \includegraphics[width=0.3\textwidth]{sss1}
                \includegraphics[width=0.35\textwidth]{sss2}
                \caption{Diagram of Boost's Simple Segregated Storage whereby the free-list is interweaved into the chunks}
            \end{figure}

            This scheme for managing chunks was impractical. It was much more reasonable to store the free-list in host memory. However, now that we have separated the free-list from the underlying chunks pool, we realized it does not have to be a list, which can result in linear allocation time. Thus, we opted to use free-sets instead. 
        \end{block}

        \begin{block}{Allocation}
            \begin{itemize}
                \item In Omega\_h, a \lstinline|StaticKokkosPool| is a non-resizable pool of memory from which an allocation can be made. The memory pool is divided into an array of contiguous fixed-size chunks. Each chunk is ordered and indexed by their position. 
                \item Instead of using a free-list, which may result in linear allocation time, we use a free-mulitset, \lstinline|freeSetBySize|, which results in logarithmic allocation time. 
            \end{itemize}
                    \begin{figure}[h]
                        \centering
                        \begin{tikzpicture}
                            \draw[fill=gray] (0,0) rectangle (0.5,0.5);
                            \node at (2.5,0.25) {allocated};

                            \draw (4.5,0) rectangle (5,0.5);
                            \node at (6,0.25) {free};
                        \end{tikzpicture}
                        \begin{tikzpicture}
                            \foreach \i in {0,...,1} {
                                \draw (\i,0) rectangle (\i+1,1);
                                \node at (\i+0.5,0.5) {\i};
                            }
                            \foreach \i in {2,...,4} {
                                \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                                \node at (\i+0.5,0.5) {\i};
                            }
                            \foreach \i in {5,...,6} {
                                \draw (\i,0) rectangle (\i+1,1);
                                \node at (\i+0.5,0.5) {\i};
                            }
                            \foreach \i in {6,...,9} {
                                \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                                \node at (\i+0.5,0.5) {\i};
                            }
                            \foreach \i in {10,...,12} {
                                \draw (\i,0) rectangle (\i+1,1);
                                \node at (\i+0.5,0.5) {\i};
                            }

                            \node (root) at (1,3) {[0,2)};
                            \node (node1) at (5.5,2) {[5,6)};
                            \node (node2) at (11.5,4) {[10,13)};

                            \draw[->] (root) |- (node1);
                            \draw[->] (root) |- (node2);
                        \end{tikzpicture}
                        \caption{a fragmented pool with \texttt{freesetbysize} showing how free regions are organized in a tree structure. index pairs are sorted top to bottom by the size of the free region they represent in decreasing order.}
                        \label{fig:freesetbysize}
                    \end{figure}
                    When an allocation $n$ bytes is requested, we search through \lstinline|freeSetBySize| to find the smallest free region that can accommodate the number of requested chunks. See Figure~\ref{fig:freesetbysizemodified}.

        \end{block}
        \column{0.3\textwidth} 
        \begin{block}{Allocation (continued)}
            
                    \begin{figure}[h]
                        \centering
                        \begin{tikzpicture}
                            \foreach \i in {0,...,1} {
                                \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                                \node at (\i+0.5,0.5) {\i};
                            }
                            \foreach \i in {2,...,4} {
                                \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                                \node at (\i+0.5,0.5) {\i};
                            }
                            \foreach \i in {5,...,6} {
                                \draw (\i,0) rectangle (\i+1,1);
                                \node at (\i+0.5,0.5) {\i};
                            }
                            \foreach \i in {6,...,9} {
                                \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                                \node at (\i+0.5,0.5) {\i};
                            }
                            \foreach \i in {10,...,12} {
                                \draw (\i,0) rectangle (\i+1,1);
                                \node at (\i+0.5,0.5) {\i};
                            }

                            \node (node1) at (5.5,2) {[5,6)};
                            \node (node2) at (11.5,3) {[10,13)};

                            \draw[->] (node1) |- (node2);
                        \end{tikzpicture}
                        \caption{A fragmented pool after an allocation requiring 2 chunks was made}
                        \label{fig:freesetbysizemodified}
                    \end{figure}
                A free region is defined as a set of contiguous free blocks between allocated regions or ends of the pool. If the found free region has more chunks than the number of requested chunks, then we split the region and only allocate the chunks requested. The remaining region remains in the free list.
            \end{block}

        \begin{block}{Deallocation and Defragmentation}
            In addition to \lstinline|freeSetBySize|,  \lstinline|freeSetByIndex| is used to achieve defragmentation in logarithmic time. As the name suggests, index pairs stored \lstinline|freeSetByIndex| in sorted in numerical order of the first index itself as depicted in Figure~\ref{fig:freeSetByIndex}. It is not possible for two index pairs to ``overlap'' or share the same start or end index.

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                    \foreach \i in {0,...,1} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {2,...,4} {
                        \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {5,...,6} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {6,...,9} {
                        \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {10,...,12} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }

                    \node (node1) at (1,2) {[0,2)};
                    \node (root) at (5.5,3) {[5,6)};
                    \node (node2) at (11.5,2) {[10,13)};

                    \draw[->] (root) -| (node1);
                    \draw[->] (root) -| (node2);

                \end{tikzpicture}
                \caption{A fragmented pool with \texttt{freeSetByIndex} showing how free regions are organized in a tree structure. Index pairs are sorted left to right by the indices of the free region they represent in increasing order.}
                \label{fig:freeSetByIndex}
            \end{figure}

            When memory is returned to the pool, the region is temporarily inserted into the tree as shown in Figure~\ref{fig:recentlyFreed}.

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                    \foreach \i in {0,...,1} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {2,...,4} {
                        \draw[fill=gray!33] (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {5,...,6} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {6,...,9} {
                        \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {10,...,12} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }

                    \node (node1) at (1,3) {[0,2)};
                    \node (root) at (5.5,4) {[5,6)};
                    \node (node2) at (11.5,2) {[10,13)};
                    \node (node3) at (3.5,2) {[2,5)};

                    \draw[->] (root) -| (node1);
                    \draw[->] (root) -| (node2);
                    \draw[->] (node1) -| (node3);

                    \draw[fill=gray!33] (14,2.25) rectangle (14.5,2.75);
                    \node at (17.5,2.5) {Recently Freed};

                \end{tikzpicture}
                \caption{A fragmented pool with \texttt{freeSetByIndex} showing with a recently returned region.}
                \label{fig:recentlyFreed}
            \end{figure}

            We then check for free regions adjacent to the recently returned region, remove the two or three index pairs if any adjacent regions were found, and then insert one index pair encompassing the defragmented region. For example, in Figure~\ref{fig:recentlyFreed} the allocation spanning blocks [2,5) is freed. This new free region is surrounded by pre-existing free regions [0,2) and [5,6). Thus we remove the three index pairs and replace them with [0,6). The result is visualized in Figure~\ref{fig:defragmented}.

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                    \foreach \i in {0,...,1} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {2,...,4} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {5,...,6} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {6,...,9} {
                        \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {10,...,12} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }

                    \node (node1) at (3,2) {[0,6)};
                    \node (root) at (11.5,3) {[10,13)};

                    \draw[->] (root) -| (node1);

                \end{tikzpicture}
                \caption{A less fragmented pool with \texttt{freeSetByIndex} shown after defragmentation}
                \label{fig:defragmented}
            \end{figure}
        \end{block}

        \begin{block}{Resizing}
            The \lstinline|KokkosPool| class maintains a list of \lstinline|StaticKokkosPool|s. 

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                    \draw (-1,-2) rectangle (14,2); % Class box
                    \node at (2,1) {KokkosPool}; % Class name

                    \foreach \i in {0,...,1} {
                        \draw (\i,0) rectangle (\i+1,-1);
                        \node at (\i+0.5,-0.5) {\i};
                    }
                    \foreach \i in {2,...,4} {
                        \draw[fill=gray] (\i,0) rectangle (\i+1,-1);
                        \node at (\i+0.5,-0.5) {\i};
                    }
                    \foreach \i in {5,...,6} {
                        \draw (\i,0) rectangle (\i+1,-1);
                        \node at (\i+0.5,-0.5) {\i};
                    }
                    \foreach \i in {6,...,9} {
                        \draw[fill=gray] (\i,0) rectangle (\i+1,-1);
                        \node at (\i+0.5,-0.5) {\i};
                    }
                    \foreach \i in {10,...,12} {
                        \draw (\i,0) rectangle (\i+1,-1);
                        \node at (\i+0.5,-0.5) {\i};
                    }
                \end{tikzpicture}
                \caption{An instance of \lstinline|KokkosPool| containing one \lstinline|StaticKokkosPool|}
                \label{fig:kokkosPool}
            \end{figure}
            In the event that we cannot find a suitable free region large enough to satisfy the allocation requested, we make a new \lstinline|StaticKokkosPool|. 

            \begin{figure}[H]
                \centering
                \begin{tikzpicture}
                    \draw (-1,-3) rectangle (27,3); % Class box
                    \node at (2,2) {KokkosPool}; % Class name

                    \foreach \i in {0,...,1} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {2,...,4} {
                        \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {5,...,6} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {6,...,9} {
                        \draw[fill=gray] (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {10,...,12} {
                        \draw (\i,0) rectangle (\i+1,1);
                        \node at (\i+0.5,0.5) {\i};
                    }
                    \foreach \i in {0,...,25} {
                        \draw (\i,-1) rectangle (\i+1,-2);
                        \node at (\i+0.5,-1.5) {\i};
                    }
                \end{tikzpicture}
                \caption{An instance of \lstinline|KokkosPool| containing one \lstinline|StaticKokkosPool|}
                \label{fig:kokkosPoolExpanded}
            \end{figure}
            \begin{itemize}
                \item When you allocate through \lstinline|KokkosPool|, it begins at the first \lstinline|StaticKokkosPool| in the list and tries to allocate from it. 
                \item If the allocation fails, it moves on to the next \lstinline|StaticKokkosPool| and tries to allocated from that. We repeat this for every \lstinline|StaticKokkosPool| in the list until we achieve a successful allocation. 
                \item If we have reached the end of the list and were not able to find a large enough free region in any of the \lstinline|StaticKokkosPool|s, we allocate a new \lstinline|StaticKokkosPool| with an appropriate size.
            \end{itemize}
        \end{block}

        \column{0.3\textwidth} 

        \begin{block}{Testing}
            \begin{itemize}
              \item The library was benchmarked with and without the memory pool against the FUN3D delta wing case from the Unstructured Grid Adaptive Working Group adaptation benchmarks \cite{deltawing} on \textbf{Oak Ridge Leadership Computing Facility's Frontier with AMD Mi250x GPUs}. First, we built Kokkos, libMeshb, and Omega\_h as described in the Omega\_h wiki \cite{buildomegah}. 
                \item We ran the 500k case, which comprised of 581,196 tetrahedrons before adaptation and 5,283,878 tetrahedrons after adaptation, with the pool disabled and with the MemoryEvents tool enabled to get a sense of the allocation patterns for this particular set of benchmarks. 
                \item From ananlyzing the memory patterns, we chose an initial pool size of 700 MiB and a fixed-chunk size of 1 kiB.
            \end{itemize}
        \end{block}

        \begin{block}{Performance}
            \begin{itemize}
                \item We ran all subsequent benchmarks without the Kokkos Tools enabled. In the 50k case without pooling, adapting 581,196 tetrahedrons to 533,937 tetrahedrons took 0.89 seconds total. 
                \item With the pool engaged, this time was reduced to 0.49 seconds, a 45\% time reduction. In the 500k case without pooling, adapting 581,196 tetrahedrons to 5,283,878 tetrahedrons took 18.28 seconds total while, with the pool enabled, adaptation only took 11.57 seconds on average, a 37\% time reduction.
                \item We then reduced the initial size of the pool to 100 KiB. This is significantly less than what we determined the benchmarks need and should require the pool to resize more often during the runtime. 
                \item We found that difference in time reduction brought about by the additional resizing behavior of the pool was less than 1\%.
            \end{itemize}

            \begin{figure}[H]
                \centering
                \includegraphics{results1.png}
                \caption{A bar plot showing the performance improvements in the delta wing case brought by the implementation of a memory pool. Less time is better.}
            \end{figure}
        \end{block}

        \begin{block}{Closing Remarks and Future Work}
            \begin{itemize}
                \item This implementation only splits and coalesces free regions, not individual chunks. 
                \item Small allocations, or allocations that don't roughly align with multiples of the chunk size to result in excessive memory waste, especially if chunks are large.
                \item Alternative implementations such as Umpire on the other hand split and coalesce individual chunks, resulting in lesser memory usage. Regardless, this implementation manages to bring substantial performance improvements in a cross-platform manner. 
                \item This implementation has been tested on AMD and NVIDIA devices with traditional, separate discrete host and device memory. We have also tested this implementation on a NVIDIA GraceHopper node which features shared device and host memory.
                \item This work was done on a pre-production supercomputer with early versions of the Aurora software development kit.
                \item In conclusion, fixed-size chunk memory pools are a viable method of managing device memory that brings substantial performance improvements in a cross-platform manner. 
            \end{itemize}
        \end{block}

        \begin{block}{References}
            \begin{FlushLeft}
                \bibliographystyle{IEEEtran_rpi.bst}
                \bibliography{refs}
            \end{FlushLeft}
        \end{block}

    \end{columns}

\end{frame}

\end{document}
